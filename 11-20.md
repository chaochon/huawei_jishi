# 11. 记负均正
```
import java.util.Scanner;

public class Main{
    
    public static void main(String[] argv){
        
        Scanner in = new Scanner(System.in);
        while(in.hasNextInt()){
            int num = in.nextInt();
            int nagtiveCnt = 0;
            int postiveCnt = 0;
            double sum = 0.0;
            
            int nnum = 0;
            for(int i=0; i<num; i++){
                nnum = in.nextInt();
                if(nnum>0){
                    sum += nnum;
                    postiveCnt++;
                }else if(nnum<0)
                    nagtiveCnt++;
            }
            System.out.print(nagtiveCnt+" ");
            System.out.printf("%.1f\n", sum/(double)(postiveCnt));
        }
    }
}
```

# 12.表示数字

### 思路

1. 给每个数字前后加上*
2. 将数值内部的冗余的**替换为空格 消除

```$xslt
import java.util.Scanner;

public class Main {
    public static void main(String[] arg){
        Scanner in = new Scanner(System.in);
        while(in.hasNextLine()){

            String ss = in.nextLine();

            StringBuilder res = new StringBuilder();

            for(int i=0; i<ss.length(); i++){
                if(ss.charAt(i)>='0'&&ss.charAt(i)<='9') {
                    res.append("*" + ss.charAt(i) + "*");
                }else{
                    res.append(ss.charAt(i));
                }
            }

            System.out.println(res.toString().replace("**", ""));
        }
    }
}
```

# 13.投票计数
```aidl
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main{

    public static void main(String[] argv){

        Scanner in = new Scanner(System.in);
        while(in.hasNextLine()){
            // 读入输入数据
            int candidateNum = Integer.parseInt(in.nextLine());
            String[] candidateNames = in.nextLine().split(" ");
            int voteNum = Integer.parseInt(in.nextLine());
            String[] votes = in.nextLine().split(" ");

            HashMap<String, Integer> map = new HashMap<>();  // 记录候选人票数
            int inValidNum = 0;  // 记录无效票数
            // 初始化候选人票数
            for(String candidateName: candidateNames){
                map.put(candidateName, 0);
            }
            // 投票
            Set<String> set = map.keySet();
            for(String vote: votes){
                if(set.contains(vote)){
                    map.put(vote, map.get(vote)+1);
                }else{
                    inValidNum++;
                }
            }
            // 输出
            for(String s: candidateNames){
                System.out.println(s+" "+":"+" "+map.get(s));
            }
            System.out.println("Invalid : "+inValidNum);
        }
    }
}
```

# 13.字符串中找出连续最长数字子串

## 13.1 小题大做 动态规划方法
```aidl
import java.util.Scanner;

public class Main{
    
    public static void main(String[] argv){
        
        Scanner in = new Scanner(System.in);
        while(in.hasNextLine()){
            String input = in.nextLine();
            
            int[] dp = new int[input.length()];     // dp数组，定义：以i为结束的连续数字字符串长度
            // 初始值
            if(input.charAt(0)>='0'&&input.charAt(0)<='9')
                dp[0] = 1;
            // 状态转移
            for(int i=1; i<input.length(); i++){
                if(input.charAt(i)>='0'&&input.charAt(i)<='9')
                    dp[i] = dp[i-1] + 1;
            }
            // 找出最大连续数值的长度
            int maxLen = 0;
            for(int n: dp){
                if(n>maxLen)
                    maxLen = n;
            }
            // 找出长度为maxLen的数值字符串
            for(int i=0; i<dp.length; i++){
                if(dp[i]==maxLen){
                    System.out.print(input.substring(i-maxLen+1, i+1));
                }
            }
            System.out.println(","+maxLen);
            
        }
    }
}
```

## 13.2 简单直接的方法
```aidl
import java.util.Scanner;

public class Main{
    
    public static void main(String[] argv){
        
        Scanner in = new Scanner(System.in);
        while(in.hasNextLine()){
            String input = in.nextLine();
            // 将input中非数字转换成a
            StringBuilder temp = new StringBuilder();
            for(char c: input.toCharArray()){
                if(c<'0'||c>'9'){
                    temp.append('a');
                }else{
                    temp.append(c);
                }
            }
            // 以a为分隔符，将数值划分出来
            String[] res = temp.toString().split("a");
            int maxLen = 0;
            // 找出最大长度
            for(String s: res){
                int len = s.length();
                if(len>maxLen){
                    maxLen = len;
                }
            }
            // 打印输出
            for(String s: res){
                if(maxLen==s.length()){
                    System.out.print(s);
                }
            }
            System.out.println(","+maxLen);
        }
    }
}
```

# 14.201301 JAVA 题目2-3级

## 14.1 递归暴力搜索
### 思路

- 每个方格只有两条方向可走，递推形式想是二叉树
- 每次到达最下角位置，则计数器加1

```aidl
import java.util.Scanner;

public class Main{

    public int counter = 0;

    public static void main(String[] argv){

        Scanner in = new Scanner(System.in);

        while(in.hasNextLine()){
            String[] line = in.nextLine().split(" ");
            int col = Integer.parseInt(line[0])+1;
            int row = Integer.parseInt(line[1])+1;
            
            Main m = new Main();
            m.dfs(0, 0, row, col);
            
            System.out.println(m.counter);
        }
    }

    public void dfs(int i, int j, int row, int col){

        if(i>=row||j>=col)
            return;

        if(i==row-1&&j==col-1) {
            counter++;
            return;
        }

        dfs(i+1, j, row, col);
        dfs(i, j+1, row, col);
    }
}
```

## 14.2动态规划
### 思路

- 定义状态：dp[i][j]表示从左上角到当前位置的可达路径数目
- 状态转移：当前位置的可达路径数目，可由上或者左通达，因此$dp[i][j]=dp[i-1][j]+dp[i][j-1]$

```aidl
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

public class Main{

    public static void main(String[] argv){

        Scanner in = new Scanner(System.in);

        while(in.hasNextLine()){
            
            String[] line = in.nextLine().split(" ");
            int col = Integer.parseInt(line[0])+1;
            int row = Integer.parseInt(line[1])+1;

            int[][] dp = new int[row][col];
            dp[0][0] = 1;
            for(int i=1; i<col; i++){
                dp[0][i] = dp[0][i-1];
            }
            for(int i=1; i<row; i++){
                dp[i][0] = dp[i-1][0];
            }
            
            for(int i=1; i<row; i++){
                for(int j=1; j<col; j++){
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
            System.out.println(dp[row-1][col-1]);
        }
    }
}
```

# 15 合法ip

```aidl
import java.util.Scanner;

public class Main{

    public static void main(String[] argv){

        Scanner in = new Scanner(System.in);

        while(in.hasNextLine()){
            // 加两个反斜杠，是因为.是正则表达式符号
            String[] line = in.nextLine().split("\\.");
            boolean res = true;
            for(String s: line){
                int n = Integer.parseInt(s);
                if(n<0||n>255){
                    res = false;
                    break;
                }
            }
            if(res)
                System.out.println("YES");
            else
                System.out.println("NO");
        }
    }


}
```
